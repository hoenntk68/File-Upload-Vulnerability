package com.labia.fileUpload.controller;

import com.labia.fileUpload.service.FileUploadService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
//import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import org.apache.tika.Tika;
import org.springframework.core.io.Resource;
import org.springframework.http.ContentDisposition;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;

@Controller
public class FileUploadController {

    @Autowired
    FileUploadService fileUploadService;

    @GetMapping("/")
    public String homePage() {
        return "upload";
    }

    @PostMapping("/uploads")
    public String uploadFile(@RequestParam("file") MultipartFile file) throws IOException {
        fileUploadService.uploadFile(file);
        return "uploadResponse";
    }

    @GetMapping("/files/{filename}")
    public ResponseEntity<Resource> viewFile(@PathVariable String filename) throws IOException {
        // Load the file from the storage location
        Resource fileResource = fileUploadService.loadFile(filename);

        // Check if the file exists
        if (fileResource.exists()) {
            // Set the content type based on the file's MIME type
            String contentType = determineContentType(filename);

            // Return the file as a ResponseEntity with appropriate headers
            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType(contentType))
                    .body(fileResource);
        } else {
            // Handle the case when the file does not exist
            return ResponseEntity.notFound().build();
        }
    }

//    private String determineContentType(String filename) {
//        String extension = getExtension(filename);
//
//        // Map file extensions to content types
//        switch (extension.toLowerCase()) {
//            case "txt":
//                return "text/plain";
//            case "pdf":
//                return "application/pdf";
//            case "jpg":
//            case "jpeg":
//                return "image/jpeg";
//            case "png":
//                return "image/png";
//            case "gif":
//                return "image/gif";
//            // Add more mappings for other file extensions as needed
//            default:
//                return "application/octet-stream"; // Default content type if the mapping is not found
//        }
//    }
    private String getExtension(String filename) {
        int dotIndex = filename.lastIndexOf(".");
        if (dotIndex != -1 && dotIndex < filename.length() - 1) {
            return filename.substring(dotIndex + 1);
        }
        return "";
    }

//    @GetMapping("/view-file/{filename}")
//    public ResponseEntity<Resource> viewFileUploaded(@PathVariable String filename) throws IOException {
//        Resource resource = fileUploadService.loadFile(filename);
//
//        // Set the appropriate Content-Disposition header
//        HttpHeaders headers = new HttpHeaders();
//        headers.setContentDispositionFormData("inline", filename);
//
//        // Set the Content-Type header based on the file's media type
//        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
//
//        return ResponseEntity.ok()
//                .headers(headers)
//                .body(resource);
//    }
    @GetMapping("/view-file/{filename}")
    public ResponseEntity<byte[]> viewFileUploaded(@PathVariable String filename) throws IOException {
        Resource resource = fileUploadService.loadFile(filename);
        System.out.println("VIEW FILE CONTROLLER CALLED");
        // Get the file content as bytes
        byte[] fileContent = Files.readAllBytes(resource.getFile().toPath());

        // Determine the appropriate Content-Type based on the file's media type
        String contentType = determineContentType(filename);

        // Set the appropriate Content-Disposition header to display the file inline
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.parseMediaType(contentType));
        headers.setContentDisposition(ContentDisposition.builder("inline")
                .filename(filename)
                .build());

        return new ResponseEntity<>(fileContent, headers, HttpStatus.OK);
    }

    private String determineContentType(String filename) {
        Tika tika = new Tika();
        return tika.detect(filename);
    }

}
